name: EventsProxParticipantes

on:
  schedule:
    - cron: '5 2 * * *'   # 02:05 UTC
  workflow_dispatch: {}

concurrency:
  group: eventos-full-scrape
  cancel-in-progress: false

jobs:
  full-scrape:
    runs-on: ubuntu-22.04
    timeout-minutes: 350

    env:
      TZ: Europe/Madrid
      OUT_DIR: ./output

      # Selenium / Chrome
      HEADLESS: "true"

      # Politeness (delays)
      THROTTLE_PANEL_MS_MIN: "150"
      THROTTLE_PANEL_MS_MAX: "300"
      THROTTLE_EVENT_S_MIN: "1"
      THROTTLE_EVENT_S_MAX: "3"
      MAX_PANELS_PER_EVENT: "0"

      # Límites de tiempo
      PER_EVENT_MAX_S: "0"
      MAX_RUNTIME_MIN: "0"

      # Chunking desactivado
      CHUNK_SIZE: "0"
      CHUNK_OFFSET: "0"

      # Debug
      DEBUG_PARTICIPANTS: "0"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Chrome & ChromeDriver
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y wget gnupg unzip
          wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
          echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" | sudo tee /etc/apt/sources.list.d/google-chrome.list
          sudo apt-get update
          sudo apt-get install -y google-chrome-stable
          CHROME_VERSION=$(google-chrome-stable --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+')
          URL="https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing/${CHROME_VERSION}/linux64/chromedriver-linux64.zip"
          if wget -q --spider "$URL"; then
            wget -O /tmp/chromedriver.zip "$URL"
            unzip -o /tmp/chromedriver.zip -d /tmp/
            sudo mv /tmp/chromedriver-linux64/chromedriver /usr/local/bin/chromedriver
            sudo chmod +x /usr/local/bin/chromedriver
          else
            sudo apt-get install -y chromium-chromedriver
            sudo ln -sf /usr/bin/chromedriver /usr/local/bin/chromedriver
          fi
          which google-chrome-stable && google-chrome-stable --version
          which chromedriver && chromedriver --version

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          pip install selenium beautifulsoup4 python-dotenv lxml requests webdriver-manager

      - name: Prepare output dirs
        run: mkdir -p "${OUT_DIR}" "${OUT_DIR}/participants"

      # ========= MÓDULO 1: EVENTOS =========
      - name: Run Module 1 (events)
        env:
          FLOW_EMAIL: ${{ secrets.FLOW_EMAILRQ }}
          FLOW_PASS:  ${{ secrets.FLOW_PASSRQ }}
          HEADLESS: "true"
          MAX_SCROLLS: "15"
          SCROLL_WAIT_S: "3.0"
          LIMIT_EVENTS: "0"
          OUT_DIR: "./output"
        run: |
          set -e
          echo "=== MÓDULO 1: EXTRACCIÓN DE EVENTOS ==="
          python ./flow_events.py --module events
          echo "=== FIN MÓDULO 1 ==="
          ls -la ./output || true

      - name: Ensure 01events.json
        run: |
          set -e
          if [ ! -f "./output/01events.json" ]; then
            echo "❌ No se generó ./output/01events.json"
            exit 1
          fi
          echo "✅ Encontrado 01events.json"
          ls -la ./output/01events.json

      # ========= MÓDULO 2: PARTICIPANTES =========
      - name: Run Module 2 (participants, full)
        env:
          FLOW_EMAIL: ${{ secrets.FLOW_EMAILRQ }}
          FLOW_PASS:  ${{ secrets.FLOW_PASSRQ }}
        run: |
          set -e
          echo "=== MÓDULO 2: PARTICIPANTES (FULL) ==="
          python ./flow_participants_DeepSek.py
          echo "=== FIN MÓDULO 2 ==="
          ls -la ./output || true
          ls -la ./output/participants || true

      - name: Sanity check JSON (plain)
        run: |
          set -e
          python - <<'PY'
          import json, pathlib, sys
          p = pathlib.Path("output/02participants.json")
          if not p.exists():
              print("❌ 02participants.json no existe"); sys.exit(1)
          data = json.loads(p.read_text(encoding="utf-8"))
          if not isinstance(data, list):
              print("❌ 02participants.json NO es una lista"); sys.exit(1)
          print("✅ Total participantes (plain):", len(data))
          PY

      - name: Gzip outputs
        run: |
          set -e
          for f in output/01events.json output/02participants.json output/02participants_debug.json output/participants/*.json; do
            if [ -f "$f" ]; then
              gzip -9 -c "$f" > "${f}.gz"
            fi
          done
          ls -la output/*.gz || true
          ls -la output/participants/*.gz || true

      - name: Validate gz files (gzip -t + JSON parse inside)
        run: |
          set -e

          # 1) Integridad gzip
          [ -f output/01events.json.gz ] && gzip -t output/01events.json.gz
          [ -f output/02participants.json.gz ] && gzip -t output/02participants.json.gz

          # 2) Parseo JSON dentro del GZ (esto evita subir basura corrupta)
          python - <<'PY'
          import gzip, json, pathlib, sys
          p = pathlib.Path("output/02participants.json.gz")
          if not p.exists():
              print("❌ No existe output/02participants.json.gz"); sys.exit(1)
          with gzip.open(p, "rt", encoding="utf-8") as f:
              data = json.load(f)
          if not isinstance(data, list):
              print("❌ El JSON dentro del GZ no es una lista"); sys.exit(1)
          print("✅ GZ OK. Participantes:", len(data))
          PY

      # ========= SUBIDA FTP (SIN RENOMBRE, porque tu FTP NO permite QUOT RNFR/RNTO/DELE) =========
      - name: Upload to FTP (gz only, robust with lftp)
        env:
          FTP_SERVER: ${{ secrets.FTP_SERVER }}
          FTP_USERNAME: ${{ secrets.FTP_USERNAME }}
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
          FTP_REMOTE_DIR: ${{ secrets.FTP_REMOTE_DIR }}
        run: |
          set -e

          if [ -z "$FTP_SERVER" ] || [ -z "$FTP_USERNAME" ] || [ -z "$FTP_PASSWORD" ] || [ -z "$FTP_REMOTE_DIR" ]; then
            echo "Variables FTP no configuradas"; exit 1
          fi

          sudo apt-get update
          sudo apt-get install -y lftp

          REMOTE_DIR="${FTP_REMOTE_DIR}/Competiciones/EventosProx/Flow/data"
          echo "Subiendo a: ${FTP_SERVER}${REMOTE_DIR}"

          # Función: intenta FTPS primero, si falla, FTP sin TLS (por compatibilidad)
          upload_one () {
            local SRC="$1"
            local DST="$2"

            echo "==> Subiendo ${SRC} -> ${DST}"

            # 1) Intento FTPS explícito (AUTH TLS)
            lftp -u "${FTP_USERNAME},${FTP_PASSWORD}" "ftp://${FTP_SERVER}" <<LFTP || FTPS_FAIL=1
set ftp:passive-mode true
set ftp:ssl-force true
set ftp:ssl-protect-data true
set ssl:verify-certificate no
set net:max-retries 5
set net:reconnect-interval-base 3
set net:timeout 30
set xfer:clobber on
cd "${REMOTE_DIR}"
put "${SRC}" -o "${DST}"
bye
LFTP

            if [ "${FTPS_FAIL:-0}" = "0" ]; then
              echo "✅ OK (FTPS): ${DST}"
              return 0
            fi

            echo "⚠️ FTPS falló; probando FTP sin TLS (fallback)…"

            # 2) Fallback FTP plano
            unset FTPS_FAIL
            lftp -u "${FTP_USERNAME},${FTP_PASSWORD}" "ftp://${FTP_SERVER}" <<LFTP
set ftp:passive-mode true
set ftp:ssl-force false
set ftp:ssl-protect-data false
set net:max-retries 5
set net:reconnect-interval-base 3
set net:timeout 30
set xfer:clobber on
cd "${REMOTE_DIR}"
put "${SRC}" -o "${DST}"
bye
LFTP

            echo "✅ OK (FTP): ${DST}"
          }

          # Subidas (solo .gz)
          [ -f "./output/01events.json.gz" ]        && upload_one "./output/01events.json.gz"        "01events.json.gz"
          [ -f "./output/02participants.json.gz" ]  && upload_one "./output/02participants.json.gz"  "02participants.json.gz"

          if [ -f "./output/02participants_debug.json.gz" ]; then
            upload_one "./output/02participants_debug.json.gz" "02participants_debug.json.gz"
          fi

          shopt -s nullglob
          for f in ./output/participants/02p_*.json.gz; do
            base=$(basename "$f")
            upload_one "$f" "participants/${base}"
          done

      - name: Upload artifacts (backup)
        uses: actions/upload-artifact@v4
        with:
          name: fullscrape-json-${{ github.run_number }}
          path: |
            output/01events.json
            output/01events.json.gz
            output/02participants.json
            output/02participants.json.gz
            output/02participants_debug.json
            output/02participants_debug.json.gz
            output/participants/*.json
            output/participants/*.json.gz
          retention-days: 10
